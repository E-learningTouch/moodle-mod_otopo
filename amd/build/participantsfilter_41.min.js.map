{"version":3,"file":"participantsfilter_41.min.js","sources":["../src/participantsfilter_41.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n/**\n * Participants filter managemnet.\n *\n * @module     core/datafilter\n * @copyright  2020 Andrew Nicols <andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Participants filter Moodle 4x.\n *\n * @copyright   2024 Nantes Universit√© <support-tice@univ-nantes.fr> (Commissioner)\n * @copyright   2024 E-learning Touch' <contact@elearningtouch.com> (Maintainer)\n * @copyright   2022 Kosmos <moodle@kosmos.fr> (Former maintainer)\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([\n    'core/datafilter/filtertypes/courseid',\n    './local/datafilter/filtertypes/otopo',\n    './local/datafilter/filtertypes/session',\n    'core_table/dynamic',\n    'core/datafilter/filtertype',\n    'core/str',\n    'core/notification',\n    'core/pending',\n    'core/datafilter/selectors',\n    'core/templates',\n    'core/custom_interaction_events',\n    'jquery'\n], function(\n    CourseFilter,\n    OtopoFilter,\n    SessionFilter,\n    DynamicTable,\n    GenericFilter,\n    Str,\n    Notification,\n    Pending,\n    Selectors,\n    Templates,\n    CustomEvents,\n    jQuery\n) {\n    return {\n        init: function(participantsRegionId, sessionFilter) {\n            // Keep a reference to the filterset.\n            const filterSet = document.querySelector(`#${participantsRegionId}`);\n            // Keep a reference to all of the active filters.\n            const activeFilters = {\n                courseid: new CourseFilter('courseid', filterSet),\n                otopo: new OtopoFilter('otopo', filterSet),\n            };\n            if (sessionFilter) {\n                activeFilters.session = new SessionFilter('session', filterSet);\n            }\n            /**\n             * Get the filter list region.\n             *\n             * @return {HTMLElement}\n             */\n            const getFilterRegion = function() {\n                filterSet.querySelector(Selectors.filterset.regions.filterlist);\n            };\n            /**\n             * Add an unselected filter row.\n             *\n             * @return {Promise}\n             */\n            const addFilterRow = function() {\n                const pendingPromise = new Pending('core_user/participantsfilter:addFilterRow');\n                const rownum = 1 + getFilterRegion().querySelectorAll(Selectors.filter.region).length;\n                return Templates.renderForPromise('core/datafilter/filter_row', {\"rownumber\": rownum})\n                    .then(({html, js}) => {\n                        const newContentNodes = Templates.appendNodeContents(getFilterRegion(), html, js);\n                        return newContentNodes;\n                    })\n                    .then(filterRow => {\n                        // Note: This is a nasty hack.\n                        // We should try to find a better way of doing this.\n                        // We do not have the list of types in a readily consumable format, so we take the pre-rendered one and copy\n                        // it in place.\n                        const typeList = filterSet.querySelector(Selectors.data.typeList);\n                        filterRow.forEach(contentNode => {\n                            const contentTypeList = contentNode.querySelector(Selectors.filter.fields.type);\n                            if (contentTypeList) {\n                                contentTypeList.innerHTML = typeList.innerHTML;\n                            }\n                        });\n                        return filterRow;\n                    })\n                    .then(filterRow => {\n                        updateFiltersOptions();\n                        return filterRow;\n                    })\n                    .then(result => {\n                        pendingPromise.resolve();\n                        return result;\n                    })\n                    .catch(Notification.exception);\n            };\n            /**\n             * Get the filter data source node fro the specified filter type.\n             *\n             * @param {String} filterType\n             * @return {HTMLElement}\n             */\n            const getFilterDataSource = function(filterType) {\n                const filterDataNode = filterSet.querySelector(Selectors.filterset.regions.datasource);\n                return filterDataNode.querySelector(Selectors.data.fields.byName(filterType));\n            };\n            /**\n             * Add a filter to the list of active filters, performing any necessary setup.\n             *\n             * @param {HTMLElement} filterRow\n             * @param {String} filterType\n             * @param {Array} initialFilterValues The initially selected values for the filter\n             * @returns {Filter}\n             */\n            const addFilter = async function(filterRow, filterType, initialFilterValues) {\n                // Name the filter on the filter row.\n                filterRow.dataset.filterType = filterType;\n                const filterDataNode = getFilterDataSource(filterType);\n                // Instantiate the Filter class.\n                let Filter = GenericFilter;\n                if (filterDataNode.dataset.filterTypeClass) {\n                    Filter = await import(filterDataNode.dataset.filterTypeClass);\n                }\n                activeFilters[filterType] = new Filter(filterType, filterSet, initialFilterValues);\n                // Disable the select.\n                const typeField = filterRow.querySelector(Selectors.filter.fields.type);\n                typeField.value = filterType;\n                typeField.disabled = 'disabled';\n                // Update the list of available filter types.\n                updateFiltersOptions();\n                return activeFilters[filterType];\n            };\n            /**\n             * Get the registered filter class for the named filter.\n             *\n             * @param {String} name\n             * @return {Object} See the Filter class.\n             */\n            const getFilterObject = function(name) {\n                return activeFilters[name];\n            };\n            /**\n             * Remove or replace the specified filter row and associated class, ensuring that if there is only one filter row,\n             * that it is replaced instead of being removed.\n             *\n             * @param {HTMLElement} filterRow\n             * @param {Boolean} refreshContent Whether to refresh the table content when removing\n             */\n            const removeOrReplaceFilterRow = function(filterRow, refreshContent) {\n                const filterCount = getFilterRegion().querySelectorAll(Selectors.filter.region).length;\n                if (filterCount === 1) {\n                    replaceFilterRow(filterRow, refreshContent);\n                } else {\n                    removeFilterRow(filterRow, refreshContent);\n                }\n            };\n            /**\n             * Remove the specified filter row and associated class.\n             *\n             * @param {HTMLElement} filterRow\n             * @param {Boolean} refreshContent Whether to refresh the table content when removing\n             */\n            const removeFilterRow = async function(filterRow, refreshContent = true) {\n                const filterType = filterRow.querySelector(Selectors.filter.fields.type);\n                const hasFilterValue = !!filterType.value;\n                // Remove the filter object.\n                removeFilterObject(filterRow.dataset.filterType);\n                // Remove the actual filter HTML.\n                filterRow.remove();\n                // Update the list of available filter types.\n                updateFiltersOptions();\n                if (hasFilterValue && refreshContent) {\n                    // Refresh the table if there was any content in this row.\n                    updateTableFromFilter();\n                }\n                // Update filter fieldset legends.\n                const filterLegends = await getAvailableFilterLegends();\n                getFilterRegion().querySelectorAll(Selectors.filter.region).forEach((filterRow, index) => {\n                    filterRow.querySelector('legend').innerText = filterLegends[index];\n                });\n            };\n            /**\n             * Replace the specified filter row with a new one.\n             *\n             * @param {HTMLElement} filterRow\n             * @param {Boolean} refreshContent Whether to refresh the table content when removing\n             * @param {Number} rowNum Number used to label the filter legend (eg Row 1). Defaults to 1 (the first filter).\n             * @return {Promise}\n             */\n            const replaceFilterRow = function(filterRow, refreshContent = true, rowNum = 1) {\n                // Remove the filter object.\n                removeFilterObject(filterRow.dataset.filterType);\n                return Templates.renderForPromise('core/datafilter/filter_row', {\"rownumber\": rowNum})\n                    .then(({html, js}) => {\n                        const newContentNodes = Templates.replaceNode(filterRow, html, js);\n                        return newContentNodes;\n                    })\n                    .then(filterRow => {\n                        // Note: This is a nasty hack.\n                        // We should try to find a better way of doing this.\n                        // We do not have the list of types in a readily consumable format, so we take the pre-rendered one and copy\n                        // it in place.\n                        const typeList = filterSet.querySelector(Selectors.data.typeList);\n                        filterRow.forEach(contentNode => {\n                            const contentTypeList = contentNode.querySelector(Selectors.filter.fields.type);\n                            if (contentTypeList) {\n                                contentTypeList.innerHTML = typeList.innerHTML;\n                            }\n                        });\n                        return filterRow;\n                    })\n                    .then(filterRow => {\n                        updateFiltersOptions();\n                        return filterRow;\n                    })\n                    .then(filterRow => {\n                        // Refresh the table.\n                        if (refreshContent) {\n                            return updateTableFromFilter();\n                        } else {\n                            return filterRow;\n                        }\n                    })\n                    .catch(Notification.exception);\n            };\n            /**\n             * Remove the Filter Object from the register.\n             *\n             * @param {string} filterName The name of the filter to be removed\n             */\n            const removeFilterObject = function(filterName) {\n                if (filterName) {\n                    const filter = getFilterObject(filterName);\n                    if (filter) {\n                        filter.tearDown();\n                        // Remove from the list of active filters.\n                        delete activeFilters[filterName];\n                    }\n                }\n            };\n            /**\n             * Remove all filters.\n             *\n             * @returns {Promise}\n             */\n            const removeAllFilters = function() {\n                const pendingPromise = new Pending('core_user/participantsfilter:setFilterFromConfig');\n                const filters = getFilterRegion().querySelectorAll(Selectors.filter.region);\n                filters.forEach(filterRow => removeOrReplaceFilterRow(filterRow, false));\n                // Refresh the table.\n                return updateTableFromFilter()\n                    .then(result => {\n                        pendingPromise.resolve();\n                        return result;\n                    });\n            };\n            /**\n             * Remove any empty filters.\n             */\n            const removeEmptyFilters = function() {\n                const filters = getFilterRegion().querySelectorAll(Selectors.filter.region);\n                filters.forEach(filterRow => {\n                    const filterType = filterRow.querySelector(Selectors.filter.fields.type);\n                    if (!filterType.value) {\n                        removeOrReplaceFilterRow(filterRow, false);\n                    }\n                });\n            };\n            /**\n             * Update the list of filter types to filter out those already selected.\n             */\n            const updateFiltersOptions = function() {\n                const filters = getFilterRegion().querySelectorAll(Selectors.filter.region);\n                filters.forEach(filterRow => {\n                    const options = filterRow.querySelectorAll(Selectors.filter.fields.type + ' option');\n                    options.forEach(option => {\n                        if (option.value === filterRow.dataset.filterType) {\n                            option.classList.remove('hidden');\n                            option.disabled = false;\n                        } else if (activeFilters[option.value]) {\n                            option.classList.add('hidden');\n                            option.disabled = true;\n                        } else {\n                            option.classList.remove('hidden');\n                            option.disabled = false;\n                        }\n                    });\n                });\n                // Configure the state of the \"Add row\" button.\n                // This button is disabled when there is a filter row available for each condition.\n                const addRowButton = filterSet.querySelector(Selectors.filterset.actions.addRow);\n                const filterDataNode = filterSet.querySelectorAll(Selectors.data.fields.all);\n                if (filterDataNode.length <= filters.length) {\n                    addRowButton.setAttribute('disabled', 'disabled');\n                } else {\n                    addRowButton.removeAttribute('disabled');\n                }\n                if (filters.length === 1) {\n                    filterSet.querySelector(Selectors.filterset.regions.filtermatch).classList.add('hidden');\n                    filterSet.querySelector(Selectors.filterset.fields.join).value = 1;\n                    filterSet.dataset.filterverb = 1;\n                } else {\n                    filterSet.querySelector(Selectors.filterset.regions.filtermatch).classList.remove('hidden');\n                }\n            };\n            /**\n             * Set the current filter options based on a provided configuration.\n             *\n             * @param {Object} config\n             * @param {Number} config.jointype\n             * @param {Object} config.filters\n             * @returns {Promise}\n             */\n            const setFilterFromConfig = function(config) {\n                const filterConfig = Object.entries(config.filters);\n                if (!filterConfig.length) {\n                    // There are no filters to set from.\n                    return Promise.resolve();\n                }\n                // Set the main join type.\n                filterSet.querySelector(Selectors.filterset.fields.join).value = config.jointype;\n                const filterPromises = filterConfig.map(([filterType, filterData]) => {\n                    if (filterType === 'courseid') {\n                        // The courseid is a special case.\n                        return false;\n                    }\n                    if (filterType === 'otopo') {\n                        // The otopo is a special case.\n                        return false;\n                    }\n                    if (filterType === 'session') {\n                        // The session is a special case.\n                        return false;\n                    }\n                    const filterValues = filterData.values;\n                    if (!filterValues.length) {\n                        // There are no values for this filter.\n                        // Skip it.\n                        return false;\n                    }\n                    return addFilterRow().then(([filterRow]) => addFilter(filterRow, filterType, filterValues));\n                }).filter(promise => promise);\n                if (!filterPromises.length) {\n                    return Promise.resolve();\n                }\n                return Promise.all(filterPromises).then(() => {\n                    return removeEmptyFilters();\n                })\n                    .then(updateFiltersOptions)\n                    .then(updateTableFromFilter);\n            };\n            /**\n             * Update the Dynamic table based upon the current filter.\n             *\n             * @return {Promise}\n             */\n            const updateTableFromFilter = function() {\n                const pendingPromise = new Pending('core_user/participantsfilter:updateTableFromFilter');\n                const filters = {};\n                Object.values(activeFilters).forEach(filter => {\n                    filters[filter.filterValue.name] = filter.filterValue;\n                });\n                return DynamicTable.setFilters(\n                    DynamicTable.getTableFromId(filterSet.dataset.tableRegion),\n                    {\n                        jointype: parseInt(filterSet.querySelector(Selectors.filterset.fields.join).value, 10),\n                        filters,\n                    }\n                )\n                    .then(result => {\n                        pendingPromise.resolve();\n                        return result;\n                    })\n                    .catch(Notification.exception);\n            };\n            /**\n             * Fetch the strings used to populate the fieldset legends for the maximum number of filters possible.\n             *\n             * @return {array}\n             */\n            const getAvailableFilterLegends = async function() {\n                const maxFilters = document.querySelector(Selectors.data.typeListSelect).length - 1;\n                let requests = [];\n                [...Array(maxFilters)].forEach((_, rowIndex) => {\n                    requests.push({\n                        \"key\": \"filterrowlegend\",\n                        \"component\": \"core\",\n                        // Add 1 since rows begin at 1 (index begins at zero).\n                        \"param\": rowIndex + 1\n                    });\n                });\n                const legendStrings = await Str.get_strings(requests)\n                    .then(fetchedStrings => {\n                        return fetchedStrings;\n                    })\n                    .catch(Notification.exception);\n                return legendStrings;\n            };\n            // Add listeners for the main actions.\n            filterSet.querySelector(Selectors.filterset.region).addEventListener('click', e => {\n                if (e.target.closest(Selectors.filterset.actions.addRow)) {\n                    e.preventDefault();\n                    addFilterRow();\n                }\n                if (e.target.closest(Selectors.filterset.actions.applyFilters)) {\n                    e.preventDefault();\n                    updateTableFromFilter();\n                }\n                if (e.target.closest(Selectors.filterset.actions.resetFilters)) {\n                    e.preventDefault();\n                    removeAllFilters();\n                }\n            });\n            // Add the listener to remove a single filter.\n            filterSet.querySelector(Selectors.filterset.regions.filterlist).addEventListener('click', e => {\n                if (e.target.closest(Selectors.filter.actions.remove)) {\n                    e.preventDefault();\n                    removeOrReplaceFilterRow(e.target.closest(Selectors.filter.region), true);\n                }\n            });\n            // Add listeners for the filter type selection.\n            let filterRegion = jQuery(getFilterRegion());\n            CustomEvents.define(filterRegion, [CustomEvents.events.accessibleChange]);\n            filterRegion.on(CustomEvents.events.accessibleChange, e => {\n                const typeField = e.target.closest(Selectors.filter.fields.type);\n                if (typeField && typeField.value) {\n                    const filter = e.target.closest(Selectors.filter.region);\n                    addFilter(filter, typeField.value);\n                }\n            });\n            filterSet.querySelector(Selectors.filterset.fields.join).addEventListener('change', e => {\n                filterSet.dataset.filterverb = e.target.value;\n            });\n            const tableRoot = DynamicTable.getTableFromId(filterSet.dataset.tableRegion);\n            const initialFilters = DynamicTable.getFilters(tableRoot);\n            if (initialFilters) {\n                const initialFilterPromise = new Pending('core_user/participantsfilter:setFilterFromConfig');\n                // Apply the initial filter configuration.\n                setFilterFromConfig(initialFilters)\n                    .then(() => initialFilterPromise.resolve())\n                    .catch();\n            }\n        }\n    };\n});\n"],"names":["define","CourseFilter","OtopoFilter","SessionFilter","DynamicTable","GenericFilter","Str","Notification","Pending","Selectors","Templates","CustomEvents","jQuery","init","participantsRegionId","sessionFilter","filterSet","document","querySelector","activeFilters","courseid","otopo","session","getFilterRegion","filterset","regions","filterlist","addFilterRow","pendingPromise","rownum","querySelectorAll","filter","region","length","renderForPromise","rownumber","then","a","html","js","appendNodeContents","newContentNodes","filterRow","typeList","data","forEach","contentNode","contentTypeList","fields","type","innerHTML","updateFiltersOptions","result","resolve","catch","exception","addFilter","async","filterType","initialFilterValues","dataset","filterDataNode","datasource","byName","getFilterDataSource","Filter","filterTypeClass","import","typeField","value","disabled","removeOrReplaceFilterRow","refreshContent","replaceFilterRow","removeFilterRow","arguments","undefined","hasFilterValue","removeFilterObject","remove","updateTableFromFilter","filterLegends","getAvailableFilterLegends","index","innerText","rowNum","b","replaceNode","filterName","name","getFilterObject","tearDown","filters","option","classList","add","addRowButton","actions","addRow","all","setAttribute","removeAttribute","filtermatch","join","filterverb","Object","values","filterValue","setFilters","getTableFromId","tableRegion","jointype","parseInt","maxFilters","typeListSelect","requests","Array","_","rowIndex","push","key","component","param","legendStrings","get_strings","fetchedStrings","addEventListener","e","target","closest","preventDefault","applyFilters","resetFilters","removeAllFilters","filterRegion","events","accessibleChange","on","tableRoot","initialFilters","getFilters","initialFilterPromise","config","filterConfig","entries","Promise","filterPromises","map","filterData","filterValues","promise","setFilterFromConfig"],"mappings":"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"}