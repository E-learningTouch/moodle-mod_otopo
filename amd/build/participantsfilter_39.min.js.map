{"version":3,"file":"participantsfilter_39.min.js","sources":["../src/participantsfilter_39.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Participants filter Moodle Pre 4x.\n *\n * @copyright   2024 Nantes Universit√© <support-tice@univ-nantes.fr> (Commissioner)\n * @copyright   2024 E-learning Touch' <contact@elearningtouch.com> (Maintainer)\n * @copyright   2022 Kosmos <moodle@kosmos.fr> (Former maintainer)\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([\n    'core_user/local/participantsfilter/filtertypes/courseid',\n    './local/participantsfilter/filtertypes/otopo',\n    './local/participantsfilter/filtertypes/session',\n    'core_table/dynamic',\n    'core_user/local/participantsfilter/filter',\n    'core/str',\n    'core/notification',\n    'core/pending',\n    'core_user/local/participantsfilter/selectors',\n    'core/templates',\n    'core/custom_interaction_events',\n    'jquery'\n], function(\n    CourseFilter,\n    OtopoFilter,\n    SessionFilter,\n    DynamicTable,\n    GenericFilter,\n    Str,\n    Notification,\n    Pending,\n    Selectors,\n    Templates,\n    CustomEvents,\n    jQuery\n) {\n    return {\n        init: function(participantsRegionId, sessionFilter) {\n            // Keep a reference to the filterset.\n            const filterSet = document.querySelector(`#${participantsRegionId}`);\n\n            // Keep a reference to all of the active filters.\n            const activeFilters = {\n                courseid: new CourseFilter('courseid', filterSet),\n                otopo: new OtopoFilter('otopo', filterSet),\n            };\n            if (sessionFilter) {\n                activeFilters.session = new SessionFilter('session', filterSet);\n            }\n\n            /**\n             * Get the filter list region.\n             *\n             * @return {HTMLElement}\n             */\n            const getFilterRegion = function() {\n                filterSet.querySelector(Selectors.filterset.regions.filterlist);\n            };\n\n            /**\n             * Add an unselected filter row.\n             *\n             * @return {Promise}\n             */\n            const addFilterRow = function() {\n                const pendingPromise = new Pending('core_user/participantsfilter:addFilterRow');\n\n                const rownum = 1 + getFilterRegion().querySelectorAll(Selectors.filter.region).length;\n                return Templates.renderForPromise('core_user/local/participantsfilter/filterrow', {\"rownumber\": rownum})\n                .then(({html, js}) => {\n                    const newContentNodes = Templates.appendNodeContents(getFilterRegion(), html, js);\n\n                    return newContentNodes;\n                })\n                .then(filterRow => {\n                    // Note: This is a nasty hack.\n                    // We should try to find a better way of doing this.\n                    // We do not have the list of types in a readily consumable format, so we take the pre-rendered one and copy\n                    // it in place.\n                    const typeList = filterSet.querySelector(Selectors.data.typeList);\n\n                    filterRow.forEach(contentNode => {\n                        const contentTypeList = contentNode.querySelector(Selectors.filter.fields.type);\n\n                        if (contentTypeList) {\n                            contentTypeList.innerHTML = typeList.innerHTML;\n                        }\n                    });\n\n                    return filterRow;\n                })\n                .then(filterRow => {\n                    updateFiltersOptions();\n\n                    return filterRow;\n                })\n                .then(result => {\n                    pendingPromise.resolve();\n\n                    return result;\n                })\n                .catch(Notification.exception);\n            };\n\n            /**\n             * Get the filter data source node fro the specified filter type.\n             *\n             * @param {String} filterType\n             * @return {HTMLElement}\n             */\n            const getFilterDataSource = filterType => {\n                const filterDataNode = filterSet.querySelector(Selectors.filterset.regions.datasource);\n\n                return filterDataNode.querySelector(Selectors.data.fields.byName(filterType));\n            };\n\n            /**\n             * Add a filter to the list of active filters, performing any necessary setup.\n             *\n             * @param {HTMLElement} filterRow\n             * @param {String} filterType\n             * @param {Array} initialFilterValues The initially selected values for the filter\n             * @returns {Filter}\n             */\n            const addFilter = async function(filterRow, filterType, initialFilterValues) {\n                // Name the filter on the filter row.\n                filterRow.dataset.filterType = filterType;\n\n                const filterDataNode = getFilterDataSource(filterType);\n\n                // Instantiate the Filter class.\n                let Filter = GenericFilter;\n                if (filterDataNode.dataset.filterTypeClass) {\n                    Filter = await import(filterDataNode.dataset.filterTypeClass);\n                }\n                activeFilters[filterType] = new Filter(filterType, filterSet, initialFilterValues);\n\n                // Disable the select.\n                const typeField = filterRow.querySelector(Selectors.filter.fields.type);\n                typeField.value = filterType;\n                typeField.disabled = 'disabled';\n\n                // Update the list of available filter types.\n                updateFiltersOptions();\n\n                return activeFilters[filterType];\n            };\n\n            /**\n             * Get the registered filter class for the named filter.\n             *\n             * @param {String} name\n             * @return {Object} See the Filter class.\n             */\n            const getFilterObject = function(name) {\n                return activeFilters[name];\n            };\n\n            /**\n             * Remove or replace the specified filter row and associated class, ensuring that if there is only one filter row,\n             * that it is replaced instead of being removed.\n             *\n             * @param {HTMLElement} filterRow\n             * @param {Boolean} refreshContent Whether to refresh the table content when removing\n             */\n            const removeOrReplaceFilterRow = function(filterRow, refreshContent) {\n                const filterCount = getFilterRegion().querySelectorAll(Selectors.filter.region).length;\n\n                if (filterCount === 1) {\n                    replaceFilterRow(filterRow, refreshContent);\n                } else {\n                    removeFilterRow(filterRow, refreshContent);\n                }\n            };\n\n            /**\n             * Remove the specified filter row and associated class.\n             *\n             * @param {HTMLElement} filterRow\n             * @param {Boolean} refreshContent Whether to refresh the table content when removing\n             */\n            const removeFilterRow = async function(filterRow, refreshContent = true) {\n                const filterType = filterRow.querySelector(Selectors.filter.fields.type);\n                const hasFilterValue = !!filterType.value;\n\n                // Remove the filter object.\n                removeFilterObject(filterRow.dataset.filterType);\n\n                // Remove the actual filter HTML.\n                filterRow.remove();\n\n                // Update the list of available filter types.\n                updateFiltersOptions();\n\n                if (hasFilterValue && refreshContent) {\n                    // Refresh the table if there was any content in this row.\n                    updateTableFromFilter();\n                }\n\n                // Update filter fieldset legends.\n                const filterLegends = await getAvailableFilterLegends();\n\n                getFilterRegion().querySelectorAll(Selectors.filter.region).forEach((filterRow, index) => {\n                    filterRow.querySelector('legend').innerText = filterLegends[index];\n                });\n\n            };\n\n            /**\n             * Replace the specified filter row with a new one.\n             *\n             * @param {HTMLElement} filterRow\n             * @param {Boolean} refreshContent Whether to refresh the table content when removing\n             * @param {Number} rowNum Number used to label the filter legend (eg Row 1). Defaults to 1 (the first filter).\n             * @return {Promise}\n             */\n            const replaceFilterRow = function(filterRow, refreshContent = true, rowNum = 1) {\n                // Remove the filter object.\n                removeFilterObject(filterRow.dataset.filterType);\n\n                return Templates.renderForPromise('core_user/local/participantsfilter/filterrow', {\"rownumber\": rowNum})\n                .then(({html, js}) => {\n                    const newContentNodes = Templates.replaceNode(filterRow, html, js);\n\n                    return newContentNodes;\n                })\n                .then(filterRow => {\n                    // Note: This is a nasty hack.\n                    // We should try to find a better way of doing this.\n                    // We do not have the list of types in a readily consumable format, so we take the pre-rendered one and copy\n                    // it in place.\n                    const typeList = filterSet.querySelector(Selectors.data.typeList);\n\n                    filterRow.forEach(contentNode => {\n                        const contentTypeList = contentNode.querySelector(Selectors.filter.fields.type);\n\n                        if (contentTypeList) {\n                            contentTypeList.innerHTML = typeList.innerHTML;\n                        }\n                    });\n\n                    return filterRow;\n                })\n                .then(filterRow => {\n                    updateFiltersOptions();\n\n                    return filterRow;\n                })\n                .then(filterRow => {\n                    // Refresh the table.\n                    if (refreshContent) {\n                        return updateTableFromFilter();\n                    } else {\n                        return filterRow;\n                    }\n                })\n                .catch(Notification.exception);\n            };\n\n            /**\n             * Remove the Filter Object from the register.\n             *\n             * @param {string} filterName The name of the filter to be removed\n             */\n            const removeFilterObject = function(filterName) {\n                if (filterName) {\n                    const filter = getFilterObject(filterName);\n                    if (filter) {\n                        filter.tearDown();\n\n                        // Remove from the list of active filters.\n                        delete activeFilters[filterName];\n                    }\n                }\n            };\n\n            /**\n             * Remove all filters.\n             *\n             * @returns {Promise}\n             */\n            const removeAllFilters = function() {\n                const pendingPromise = new Pending('core_user/participantsfilter:setFilterFromConfig');\n\n                const filters = getFilterRegion().querySelectorAll(Selectors.filter.region);\n                filters.forEach(filterRow => removeOrReplaceFilterRow(filterRow, false));\n\n                // Refresh the table.\n                return updateTableFromFilter()\n                .then(result => {\n                    pendingPromise.resolve();\n\n                    return result;\n                });\n            };\n\n            /**\n             * Remove any empty filters.\n             */\n            const removeEmptyFilters = function() {\n                const filters = getFilterRegion().querySelectorAll(Selectors.filter.region);\n                filters.forEach(filterRow => {\n                    const filterType = filterRow.querySelector(Selectors.filter.fields.type);\n                    if (!filterType.value) {\n                        removeOrReplaceFilterRow(filterRow, false);\n                    }\n                });\n            };\n\n            /**\n             * Update the list of filter types to filter out those already selected.\n             */\n            const updateFiltersOptions = function() {\n                const filters = getFilterRegion().querySelectorAll(Selectors.filter.region);\n                filters.forEach(filterRow => {\n                    const options = filterRow.querySelectorAll(Selectors.filter.fields.type + ' option');\n                    options.forEach(option => {\n                        if (option.value === filterRow.dataset.filterType) {\n                            option.classList.remove('hidden');\n                            option.disabled = false;\n                        } else if (activeFilters[option.value]) {\n                            option.classList.add('hidden');\n                            option.disabled = true;\n                        } else {\n                            option.classList.remove('hidden');\n                            option.disabled = false;\n                        }\n                    });\n                });\n\n                // Configure the state of the \"Add row\" button.\n                // This button is disabled when there is a filter row available for each condition.\n                const addRowButton = filterSet.querySelector(Selectors.filterset.actions.addRow);\n                const filterDataNode = filterSet.querySelectorAll(Selectors.data.fields.all);\n                if (filterDataNode.length <= filters.length) {\n                    addRowButton.setAttribute('disabled', 'disabled');\n                } else {\n                    addRowButton.removeAttribute('disabled');\n                }\n\n                if (filters.length === 1) {\n                    filterSet.querySelector(Selectors.filterset.regions.filtermatch).classList.add('hidden');\n                    filterSet.querySelector(Selectors.filterset.fields.join).value = 1;\n                    filterSet.dataset.filterverb = 1;\n                } else {\n                    filterSet.querySelector(Selectors.filterset.regions.filtermatch).classList.remove('hidden');\n                }\n            };\n\n            /**\n             * Set the current filter options based on a provided configuration.\n             *\n             * @param {Object} config\n             * @param {Number} config.jointype\n             * @param {Object} config.filters\n             * @returns {Promise}\n             */\n            const setFilterFromConfig = function(config) {\n                const filterConfig = Object.entries(config.filters);\n\n                if (!filterConfig.length) {\n                    // There are no filters to set from.\n                    return Promise.resolve();\n                }\n\n                // Set the main join type.\n                filterSet.querySelector(Selectors.filterset.fields.join).value = config.jointype;\n\n                const filterPromises = filterConfig.map(([filterType, filterData]) => {\n                    if (filterType === 'courseid') {\n                        // The courseid is a special case.\n                        return false;\n                    }\n                    if (filterType === 'otopo') {\n                        // The otopo is a special case.\n                        return false;\n                    }\n                    if (filterType === 'session') {\n                        // The session is a special case.\n                        return false;\n                    }\n\n                    const filterValues = filterData.values;\n\n                    if (!filterValues.length) {\n                        // There are no values for this filter.\n                        // Skip it.\n                        return false;\n                    }\n\n                    return addFilterRow().then(([filterRow]) => addFilter(filterRow, filterType, filterValues));\n                }).filter(promise => promise);\n\n                if (!filterPromises.length) {\n                    return Promise.resolve();\n                }\n\n                return Promise.all(filterPromises).then(() => {\n                    return removeEmptyFilters();\n                })\n                .then(updateFiltersOptions)\n                .then(updateTableFromFilter);\n            };\n\n            /**\n             * Update the Dynamic table based upon the current filter.\n             *\n             * @return {Promise}\n             */\n            const updateTableFromFilter = function() {\n                const pendingPromise = new Pending('core_user/participantsfilter:updateTableFromFilter');\n\n                const filters = {};\n                Object.values(activeFilters).forEach(filter => {\n                    filters[filter.filterValue.name] = filter.filterValue;\n                });\n\n                return DynamicTable.setFilters(\n                    DynamicTable.getTableFromId(filterSet.dataset.tableRegion),\n                    {\n                        jointype: parseInt(filterSet.querySelector(Selectors.filterset.fields.join).value, 10),\n                        filters,\n                    }\n                )\n                .then(result => {\n                    pendingPromise.resolve();\n\n                    return result;\n                })\n                .catch(Notification.exception);\n            };\n\n            /**\n             * Fetch the strings used to populate the fieldset legends for the maximum number of filters possible.\n             *\n             * @return {array}\n             */\n            const getAvailableFilterLegends = async function() {\n                const maxFilters = document.querySelector(Selectors.data.typeListSelect).length - 1;\n                let requests = [];\n\n                [...Array(maxFilters)].forEach((_, rowIndex) => {\n                    requests.push({\n                        \"key\": \"filterrowlegend\",\n                        \"component\": \"core_user\",\n                        // Add 1 since rows begin at 1 (index begins at zero).\n                        \"param\": rowIndex + 1\n                    });\n                });\n\n                const legendStrings = await Str.get_strings(requests)\n                .then(fetchedStrings => {\n                    return fetchedStrings;\n                })\n                .catch(Notification.exception);\n\n                return legendStrings;\n            };\n\n            // Add listeners for the main actions.\n            filterSet.querySelector(Selectors.filterset.region).addEventListener('click', e => {\n                if (e.target.closest(Selectors.filterset.actions.addRow)) {\n                    e.preventDefault();\n\n                    addFilterRow();\n                }\n\n                if (e.target.closest(Selectors.filterset.actions.applyFilters)) {\n                    e.preventDefault();\n\n                    updateTableFromFilter();\n                }\n\n                if (e.target.closest(Selectors.filterset.actions.resetFilters)) {\n                    e.preventDefault();\n\n                    removeAllFilters();\n                }\n            });\n\n            // Add the listener to remove a single filter.\n            filterSet.querySelector(Selectors.filterset.regions.filterlist).addEventListener('click', e => {\n                if (e.target.closest(Selectors.filter.actions.remove)) {\n                    e.preventDefault();\n\n                    removeOrReplaceFilterRow(e.target.closest(Selectors.filter.region), true);\n                }\n            });\n\n            // Add listeners for the filter type selection.\n            let filterRegion = jQuery(getFilterRegion());\n            CustomEvents.define(filterRegion, [CustomEvents.events.accessibleChange]);\n            filterRegion.on(CustomEvents.events.accessibleChange, e => {\n                const typeField = e.target.closest(Selectors.filter.fields.type);\n                if (typeField && typeField.value) {\n                    const filter = e.target.closest(Selectors.filter.region);\n\n                    addFilter(filter, typeField.value);\n                }\n            });\n\n            filterSet.querySelector(Selectors.filterset.fields.join).addEventListener('change', e => {\n                filterSet.dataset.filterverb = e.target.value;\n            });\n\n            const tableRoot = DynamicTable.getTableFromId(filterSet.dataset.tableRegion);\n            const initialFilters = DynamicTable.getFilters(tableRoot);\n            if (initialFilters) {\n                const initialFilterPromise = new Pending('core_user/participantsfilter:setFilterFromConfig');\n                // Apply the initial filter configuration.\n                setFilterFromConfig(initialFilters)\n                .then(() => initialFilterPromise.resolve())\n                .catch();\n            }\n        }\n    };\n});\n"],"names":["define","CourseFilter","OtopoFilter","SessionFilter","DynamicTable","GenericFilter","Str","Notification","Pending","Selectors","Templates","CustomEvents","jQuery","init","participantsRegionId","sessionFilter","filterSet","document","querySelector","activeFilters","courseid","otopo","session","getFilterRegion","filterset","regions","filterlist","addFilterRow","pendingPromise","rownum","querySelectorAll","filter","region","length","renderForPromise","rownumber","then","a","html","js","appendNodeContents","newContentNodes","filterRow","typeList","data","forEach","contentNode","contentTypeList","fields","type","innerHTML","updateFiltersOptions","result","resolve","catch","exception","addFilter","async","filterType","initialFilterValues","dataset","filterDataNode","datasource","byName","getFilterDataSource","Filter","filterTypeClass","import","typeField","value","disabled","removeOrReplaceFilterRow","refreshContent","replaceFilterRow","removeFilterRow","arguments","undefined","hasFilterValue","removeFilterObject","remove","updateTableFromFilter","filterLegends","getAvailableFilterLegends","index","innerText","rowNum","b","replaceNode","filterName","name","getFilterObject","tearDown","filters","option","classList","add","addRowButton","actions","addRow","all","setAttribute","removeAttribute","filtermatch","join","filterverb","Object","values","filterValue","setFilters","getTableFromId","tableRegion","jointype","parseInt","maxFilters","typeListSelect","requests","Array","_","rowIndex","push","key","component","param","legendStrings","get_strings","fetchedStrings","addEventListener","e","target","closest","preventDefault","applyFilters","resetFilters","removeAllFilters","filterRegion","events","accessibleChange","on","tableRoot","initialFilters","getFilters","initialFilterPromise","config","filterConfig","entries","Promise","filterPromises","map","filterData","filterValues","promise","setFilterFromConfig"],"mappings":"AAuBAA,OAAO,kCAAA,CACH,0DACA,+CACA,iDACA,qBACA,4CACA,WACA,oBACA,eACA,+CACA,iBACA,iCACA,WACD,SACCC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAO,CACHC,KAAM,SAASC,EAAsBC,GAEjC,MAAMC,EAAYC,SAASC,cAAc,IAAIJ,KAGvCK,EAAgB,CAClBC,SAAU,IAAInB,EAAa,WAAYe,GACvCK,MAAO,IAAInB,EAAY,QAASc,IAEhCD,IACAI,EAAcG,QAAU,IAAInB,EAAc,UAAWa,IAQzD,MAAMO,EAAkB,WACpBP,EAAUE,cAAcT,EAAUe,UAAUC,QAAQC,WACxD,EAOMC,EAAe,WACjB,MAAMC,EAAiB,IAAIpB,EAAQ,6CAE7BqB,EAAS,EAAIN,IAAkBO,iBAAiBrB,EAAUsB,OAAOC,QAAQC,OAC/E,OAAOvB,EAAUwB,iBAAiB,+CAAgD,CAACC,UAAaN,IAC/FO,MAAKC,IAAC,IAACC,KAAAA,EAAMC,GAAAA,GAAGF,EAGb,OAFwB3B,EAAU8B,mBAAmBjB,IAAmBe,EAAMC,EAEvEE,IAEVL,MAAKM,IAKF,MAAMC,EAAW3B,EAAUE,cAAcT,EAAUmC,KAAKD,UAUxD,OARAD,EAAUG,SAAQC,IACd,MAAMC,EAAkBD,EAAY5B,cAAcT,EAAUsB,OAAOiB,OAAOC,MAEtEF,IACAA,EAAgBG,UAAYP,EAASO,UAAS,IAI/CR,KAEVN,MAAKM,IACFS,IAEOT,KAEVN,MAAKgB,IACFxB,EAAeyB,UAERD,KAEVE,MAAM/C,EAAagD,UACxB,EAsBMC,EAAYC,eAAef,EAAWgB,EAAYC,GAEpDjB,EAAUkB,QAAQF,WAAaA,EAE/B,MAAMG,EAlBkBH,IACD1C,EAAUE,cAAcT,EAAUe,UAAUC,QAAQqC,YAErD5C,cAAcT,EAAUmC,KAAKI,OAAOe,OAAOL,IAe1CM,CAAoBN,GAG3C,IAAIO,EAAS5D,EACTwD,EAAeD,QAAQM,kBACvBD,QAAeE,OAAON,EAAeD,QAAQM,kBAEjD/C,EAAcuC,GAAc,IAAIO,EAAOP,EAAY1C,EAAW2C,GAG9D,MAAMS,EAAY1B,EAAUxB,cAAcT,EAAUsB,OAAOiB,OAAOC,MAOlE,OANAmB,EAAUC,MAAQX,EAClBU,EAAUE,SAAW,WAGrBnB,IAEOhC,EAAcuC,EACzB,EAmBMa,EAA2B,SAAS7B,EAAW8B,GAG7B,IAFAjD,IAAkBO,iBAAiBrB,EAAUsB,OAAOC,QAAQC,OAG5EwC,EAAiB/B,EAAW8B,GAE5BE,EAAgBhC,EAAW8B,EAEnC,EAQME,EAAkBjB,eAAef,GAAW,IAAA8B,IAAcG,UAAA1C,OAAA,QAAA2C,IAAAD,UAAA,KAAAA,UAAA,GAC5D,MACME,IADanC,EAAUxB,cAAcT,EAAUsB,OAAOiB,OAAOC,MAC/BoB,MAGpCS,EAAmBpC,EAAUkB,QAAQF,YAGrChB,EAAUqC,SAGV5B,IAEI0B,GAAkBL,GAElBQ,IAIJ,MAAMC,QAAsBC,IAE5B3D,IAAkBO,iBAAiBrB,EAAUsB,OAAOC,QAAQa,SAAQ,CAACH,EAAWyC,KAC5EzC,EAAUxB,cAAc,UAAUkE,UAAYH,EAAcE,EAAK,GAGzE,EAUMV,EAAmB,SAAS/B,GAA8C,IAAnC8B,IAAcG,UAAA1C,OAAA0C,QAAAC,IAAAD,UAAAC,KAAAD,UAAS,GAAAU,EAAMV,UAAA1C,OAAA,QAAA2C,IAAAD,UAAA,GAAAA,UAAA,GAAG,EAIzE,OAFAG,EAAmBpC,EAAUkB,QAAQF,YAE9BhD,EAAUwB,iBAAiB,+CAAgD,CAACC,UAAakD,IAC/FjD,MAAKkD,IAAC,IAAChD,KAAAA,EAAMC,GAAAA,GAAG+C,EAGb,OAFwB5E,EAAU6E,YAAY7C,EAAWJ,EAAMC,EAExDE,IAEVL,MAAKM,IAKF,MAAMC,EAAW3B,EAAUE,cAAcT,EAAUmC,KAAKD,UAUxD,OARAD,EAAUG,SAAQC,IACd,MAAMC,EAAkBD,EAAY5B,cAAcT,EAAUsB,OAAOiB,OAAOC,MAEtEF,IACAA,EAAgBG,UAAYP,EAASO,UAE7C,IAEOR,KAEVN,MAAKM,IACFS,IAEOT,KAEVN,MAAKM,GAEE8B,EACOQ,IAEAtC,IAGdY,MAAM/C,EAAagD,UACxB,EAOMuB,EAAqB,SAASU,GAChC,GAAIA,EAAY,CACZ,MAAMzD,EAhHU,SAAS0D,GAC7B,OAAOtE,EAAcsE,EACzB,CA8GuBC,CAAgBF,GAC3BzD,IACAA,EAAO4D,kBAGAxE,EAAcqE,GAE7B,CACJ,EAsCMrC,EAAuB,WACzB,MAAMyC,EAAUrE,IAAkBO,iBAAiBrB,EAAUsB,OAAOC,QACpE4D,EAAQ/C,SAAQH,IACIA,EAAUZ,iBAAiBrB,EAAUsB,OAAOiB,OAAOC,KAAO,WAClEJ,SAAQgD,IACRA,EAAOxB,QAAU3B,EAAUkB,QAAQF,YACnCmC,EAAOC,UAAUf,OAAO,UACxBc,EAAOvB,UAAW,GACXnD,EAAc0E,EAAOxB,QAC5BwB,EAAOC,UAAUC,IAAI,UACrBF,EAAOvB,UAAW,IAElBuB,EAAOC,UAAUf,OAAO,UACxBc,EAAOvB,UAAW,EAAK,GAE9B,IAKL,MAAM0B,EAAehF,EAAUE,cAAcT,EAAUe,UAAUyE,QAAQC,QAClDlF,EAAUc,iBAAiBrB,EAAUmC,KAAKI,OAAOmD,KACrDlE,QAAU2D,EAAQ3D,OACjC+D,EAAaI,aAAa,WAAY,YAEtCJ,EAAaK,gBAAgB,YAGV,IAAnBT,EAAQ3D,QACRjB,EAAUE,cAAcT,EAAUe,UAAUC,QAAQ6E,aAAaR,UAAUC,IAAI,UAC/E/E,EAAUE,cAAcT,EAAUe,UAAUwB,OAAOuD,MAAMlC,MAAQ,EACjErD,EAAU4C,QAAQ4C,WAAa,GAE/BxF,EAAUE,cAAcT,EAAUe,UAAUC,QAAQ6E,aAAaR,UAAUf,OAAO,SAE1F,EA8DMC,EAAwB,WAC1B,MAAMpD,EAAiB,IAAIpB,EAAQ,sDAE7BoF,EAAU,CAAE,EAKlB,OAJAa,OAAOC,OAAOvF,GAAe0B,SAAQd,IACjC6D,EAAQ7D,EAAO4E,YAAYlB,MAAQ1D,EAAO4E,WAAAA,IAGvCvG,EAAawG,WAChBxG,EAAayG,eAAe7F,EAAU4C,QAAQkD,aAC9C,CACIC,SAAUC,SAAShG,EAAUE,cAAcT,EAAUe,UAAUwB,OAAOuD,MAAMlC,MAAO,IACnFuB,QAAAA,IAGPxD,MAAKgB,IACFxB,EAAeyB,UAERD,KAEVE,MAAM/C,EAAagD,UACxB,EAOM2B,EAA4BzB,iBAC9B,MAAMwD,EAAahG,SAASC,cAAcT,EAAUmC,KAAKsE,gBAAgBjF,OAAS,EAClF,IAAIkF,EAAW,GAEf,IAAIC,MAAMH,IAAapE,SAAQ,CAACwE,EAAGC,KAC/BH,EAASI,KAAK,CACVC,IAAO,kBACPC,UAAa,YAEbC,MAASJ,EAAW,OAI5B,MAAMK,QAAsBrH,EAAIsH,YAAYT,GAC3C/E,MAAKyF,GACKA,IAEVvE,MAAM/C,EAAagD,WAEpB,OAAOoE,CACX,EAGA3G,EAAUE,cAAcT,EAAUe,UAAUQ,QAAQ8F,iBAAiB,SAASC,IACtEA,EAAEC,OAAOC,QAAQxH,EAAUe,UAAUyE,QAAQC,UAC7C6B,EAAEG,iBAEFvG,KAGAoG,EAAEC,OAAOC,QAAQxH,EAAUe,UAAUyE,QAAQkC,gBAC7CJ,EAAEG,iBAEFlD,KAGA+C,EAAEC,OAAOC,QAAQxH,EAAUe,UAAUyE,QAAQmC,gBAC7CL,EAAEG,iBAjMe,WACrB,MAAMtG,EAAiB,IAAIpB,EAAQ,oDAEnBe,IAAkBO,iBAAiBrB,EAAUsB,OAAOC,QAC5Da,SAAQH,GAAa6B,EAAyB7B,GAAW,KAG1DsC,IACN5C,MAAKgB,IACFxB,EAAeyB,UAERD,IAEf,CAsLQiF,GAER,IAGArH,EAAUE,cAAcT,EAAUe,UAAUC,QAAQC,YAAYoG,iBAAiB,SAASC,IAClFA,EAAEC,OAAOC,QAAQxH,EAAUsB,OAAOkE,QAAQlB,UAC1CgD,EAAEG,iBAEF3D,EAAyBwD,EAAEC,OAAOC,QAAQxH,EAAUsB,OAAOC,SAAS,GAE5E,IAGA,IAAIsG,EAAe1H,EAAOW,KAC1BZ,EAAaX,OAAOsI,EAAc,CAAC3H,EAAa4H,OAAOC,mBACvDF,EAAaG,GAAG9H,EAAa4H,OAAOC,kBAAkBT,IAClD,MAAM3D,EAAY2D,EAAEC,OAAOC,QAAQxH,EAAUsB,OAAOiB,OAAOC,MAC3D,GAAImB,GAAaA,EAAUC,MAAO,CAC9B,MAAMtC,EAASgG,EAAEC,OAAOC,QAAQxH,EAAUsB,OAAOC,QAEjDwB,EAAUzB,EAAQqC,EAAUC,MAChC,KAGJrD,EAAUE,cAAcT,EAAUe,UAAUwB,OAAOuD,MAAMuB,iBAAiB,UAAUC,IAChF/G,EAAU4C,QAAQ4C,WAAauB,EAAEC,OAAO3D,KAAAA,IAG5C,MAAMqE,EAAYtI,EAAayG,eAAe7F,EAAU4C,QAAQkD,aAC1D6B,EAAiBvI,EAAawI,WAAWF,GAC/C,GAAIC,EAAgB,CAChB,MAAME,EAAuB,IAAIrI,EAAQ,qDAvJjB,SAASsI,GACjC,MAAMC,EAAetC,OAAOuC,QAAQF,EAAOlD,SAE3C,IAAKmD,EAAa9G,OAEd,OAAOgH,QAAQ5F,UAInBrC,EAAUE,cAAcT,EAAUe,UAAUwB,OAAOuD,MAAMlC,MAAQyE,EAAO/B,SAExE,MAAMmC,EAAiBH,EAAaI,KAAI9G,IAAC,IAACqB,EAAY0F,GAAW/G,EAC7D,GAAmB,aAAfqB,EAEA,OAAO,EAEX,GAAmB,UAAfA,EAEA,OAAO,EAEX,GAAmB,YAAfA,EAEA,OAAO,EAGX,MAAM2F,EAAeD,EAAW1C,OAAO,QAElC2C,EAAapH,QAMXN,IAAeS,MAAKC,IAAC,IAACK,GAAUL,EAAK,OAAAmB,EAAUd,EAAWgB,EAAY2F,EAAY,GAC7F,IAAGtH,QAAOuH,GAAWA,IAAS,OAEzBJ,EAAejH,OAIbgH,QAAQ9C,IAAI+C,GAAgB9G,MAAK,KAjGxBb,IAAkBO,iBAAiBrB,EAAUsB,OAAOC,QAC5Da,SAAQH,KACOA,EAAUxB,cAAcT,EAAUsB,OAAOiB,OAAOC,MACnDoB,OACZE,EAAyB7B,GAAW,EAE5C,GA6FC,IACAN,KAAKe,GACLf,KAAK4C,GAPKiE,QAAQ5F,SAQvB,EA4GIkG,CAAoBZ,GACnBvG,MAAK,IAAMyG,EAAqBxF,YAChCC,OACL,CACJ,EAER"}